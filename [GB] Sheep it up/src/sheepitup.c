////////////////////////////////////////////////////////////////////////////////
// 		 Sheep it up! - A tiny GB/GBC game for the bitbitjam4 game jam
//
//		by Dr. Ludos (http://www.ludoscience.com)
//
////////////////////////////////////////////////////////////////////////////////

// INCLUDE GBDK FUNCTION LIBRARY														
#include <gb/gb.h>
// INCLUDE HANDY HARDWARE REFERENCES
#include <gb/hardware.h>
// INCLUDE RANDOM FUNCTIONS
#include <rand.h>
//INCLUDE FONT (+CUSTOM COLOR) AND TEXT DISPLAY FUNCTIONS
#include <stdio.h>
#include <gb/font.h>
#include <gb/drawing.h>



//================================
//========  GRAPHICS ==============
//================================

//SPRITE DATA - Player - 2 SPRITE (16*16) - STORED IN ROM (=> const)
const unsigned char gfx_sheep[]={
  0x0F,0x00,0x3F,0x0F,0x7F,0x3F,0x7F,0x38,
  0xFF,0x70,0xFD,0x72,0xFD,0x72,0xBF,0x78,
  0x7F,0x38,0x5F,0x3C,0x2F,0x1F,0x27,0x1F,
  0x18,0x07,0x0F,0x00,0x0C,0x00,0x0C,0x00,
  0xF0,0x00,0xFC,0xF0,0xFE,0xFC,0xFE,0x1C,
  0xFD,0x0E,0xBF,0x4E,0xBF,0x4E,0xFD,0x1E,
  0xFA,0x1C,0xFA,0x3C,0xF4,0xF8,0xC4,0xF8,
  0x18,0xE0,0xF0,0x00,0x30,0x00,0x30,0x00,
  0x0F,0x00,0x3F,0x08,0x7D,0x32,0xFD,0x72,
  0xFF,0x70,0xFF,0x78,0xBF,0x78,0x5F,0x3C,
  0x47,0x3F,0x2C,0x13,0x1F,0x00,0x0C,0x00,
  0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xF0,0x00,0xFC,0x10,0xBA,0x4C,0xBD,0x4E,
  0xFD,0x0E,0xFD,0x1E,0xFD,0x1E,0xFA,0x3C,
  0x82,0xFC,0x34,0xC8,0xF8,0x00,0x30,0x00,
  0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x0F,0x00,0x3F,0x0F,0x7F,0x38,0xFF,0x70,
  0xFD,0x72,0xFD,0x72,0xBF,0x78,0x5F,0x38,
  0x47,0x3C,0x2C,0x13,0x1F,0x00,0x0C,0x00,
  0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xF0,0x00,0xFC,0xF0,0xFA,0x1C,0xFD,0x0E,
  0xBD,0x4E,0xBD,0x4E,0xFD,0x1E,0xFA,0x1C,
  0xC2,0x3C,0x34,0xC8,0xF8,0x00,0x30,0x00,
  0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

//SPRITE DATA - Velcro - 1 SPRITE (16*16) - STORED IN ROM (=> const)
const unsigned char gfx_velcro[] =
{
  0x7F,0x7F,0xC0,0xBF,0xFF,0x80,0xFF,0xFF,
  0x55,0x55,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xFC,0xFC,0x1E,0xE2,0xFE,0x02,0xFE,0xFE,
  0x54,0x54,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
	
//BACKGROUND DATA - 2 SPRITES - STORED IN ROM (=> const)
const unsigned char gfx_bg[] = {
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

//The font used is GBDK default one, loaded and colorized by using the functions in <gb/font.h>



//======= TITLE SCREEN MAP & TILE DATA ==============
//Converted from a hand-drawn PNG image using Game Boy Tile Data Generator : http://www.chrisantonellis.com/gameboy/gbtdg/

//Title Screen - Map Data (total : 144*128 / 18*16 / 288 Tiles)
//So we split it in two parts to stay below the 256 tiles limit that GBDK can handle in a single map (it uses UINT8)
//It also allow us to draw for example the game name separately from the game intro picture, while they are closer to each other in the original picture / tile data

//First, the game name
const unsigned char title_name_map_data[] ={
  0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0D,0x0E,
  0x0F,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x09,0x1A,0x1B,0x09,0x1C,
  0x1D,0x1E,0x1F,0x20
};

//Then the game pretty intro picture 
const unsigned char title_picture_map_data[] ={
  0x09,0x09,0x21,0x22,0x23,0x24,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x25,0x26,0x27,0x28,0x09,0x09,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,0x09,
  0x09,0x09,0x09,0x09,0x30,0x31,0x32,0x33,0x09,0x09,0x34,0x35,0x36,0x37,0x38,0x39,
  0x3A,0x3B,0x09,0x09,0x09,0x09,0x3C,0x3D,0x3E,0x3F,0x09,0x09,0x09,0x09,0x40,0x41,
  0x42,0x43,0x44,0x45,0x46,0x47,0x09,0x09,0x09,0x09,0x48,0x49,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x4A,0x4B,0x4C,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x4D,0x4E,0x4F,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x50,0x51,0x24,0x09,0x09,0x09,0x09,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x09,
  0x09,0x09,0x5A,0x5B,0x5C,0x5D,0x5E,0x09,0x09,0x5F,0x60,0x61,0x62,0x63,0x64,0x65,
  0x66,0x67,0x68,0x09,0x09,0x69,0x6A,0x6B,0x6C,0x6D,0x09,0x6E,0x6F,0x70,0x71,0x09,
  0x69,0x6A,0x72,0x73,0x74,0x75,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x76,0x77,
  0x09,0x09,0x09,0x09,0x78,0x79,0x09,0x7A,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x7B,
  0x7C,0x7D,0x7E,0x09,0x7F,0x80,0x81,0x82,0x83,0x09,0x84,0x85,0x59,0x09,0x09,0x09,
  0x09,0x86,0x87,0x88,0x4A,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x09,0x09,0x8F,0x90,0x91,
  0x09,0x09,0x09,0x09,0x86,0x92,0x09,0x09,0x93,0x94,0x95,0x96,0x71,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x97,0x98,0x99,0x9A,0x9B,0x9C
};

//Title Screen - Tile Data (148 unique tiles) - 
const unsigned char title_tile_data[] ={
  0x00,0x01,0x01,0x02,0x03,0x04,0x06,0x09,0x06,0x09,0x06,0x09,0x03,0x04,0x01,0x02,
  0x00,0xF8,0xF8,0x04,0x0C,0xF2,0x04,0x0A,0x00,0x04,0x00,0x00,0x00,0xE0,0xE0,0x18,
  0x00,0x38,0x10,0x28,0x10,0x28,0x10,0x28,0x10,0x28,0x10,0x28,0x10,0x2F,0x1F,0x20,
  0x00,0x38,0x10,0x28,0x10,0x28,0x10,0x28,0x10,0x28,0x10,0x28,0x10,0xE8,0xF0,0x08,
  0x00,0xFF,0x7F,0x80,0x40,0xBF,0x40,0xA0,0x40,0xA0,0x40,0xA0,0x40,0xA0,0x40,0xBF,
  0x00,0xE3,0xC1,0x22,0x01,0xE2,0x01,0x02,0x01,0x02,0x01,0x02,0x01,0x02,0x01,0x02,
  0x00,0xFF,0xFF,0x00,0x00,0xFF,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0xFC,
  0x00,0x8F,0x07,0x88,0x04,0x8B,0x04,0x0A,0x04,0x0A,0x04,0x0A,0x04,0x0A,0x04,0x0B,
  0x00,0xF0,0xF0,0x08,0x18,0xE4,0x08,0x14,0x08,0x14,0x08,0x14,0x08,0x14,0x18,0xE4,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0xE3,0x41,0xA2,0x40,0xA3,0x40,0xA0,0x40,0xA0,0x40,0xA0,0x40,0xA0,0x40,0xA0,
  0x00,0xFF,0xFF,0x00,0x10,0xEF,0x10,0x28,0x10,0x28,0x10,0x28,0x10,0x28,0x10,0x28,
  0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x1C,0x08,0x14,0x08,0x14,0x08,0x14,0x08,0x14,0x08,0x14,0x08,0x14,0x08,0x14,
  0x00,0x7F,0x3F,0x40,0x20,0x5F,0x20,0x50,0x20,0x50,0x20,0x50,0x20,0x50,0x20,0x5F,
  0x00,0x80,0x80,0x40,0xC0,0x20,0x40,0xA0,0x40,0xA0,0x40,0xA0,0x40,0xA0,0xC0,0x20,
  0x00,0x70,0x20,0x50,0x20,0x50,0x20,0x50,0x20,0x50,0x20,0x50,0x20,0x50,0x20,0x50,
  0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x04,0x04,0x0A,0x06,0x09,0x03,0x04,0x00,0x03,
  0x78,0x84,0x0C,0x72,0x04,0x0A,0x04,0x0A,0x04,0x0A,0x0C,0xF2,0xF8,0x04,0x00,0xF8,
  0x10,0x2F,0x10,0x28,0x10,0x28,0x10,0x28,0x10,0x28,0x10,0x28,0x10,0x28,0x00,0x38,
  0x10,0xE8,0x10,0x28,0x10,0x28,0x10,0x28,0x10,0x28,0x10,0x28,0x10,0x28,0x00,0x38,
  0x7E,0x81,0x40,0xBF,0x40,0xA0,0x40,0xA0,0x40,0xA0,0x40,0xBF,0x7F,0x80,0x00,0xFF,
  0x01,0x02,0x01,0x02,0x01,0x02,0x01,0x02,0x01,0x02,0x01,0xE2,0xC1,0x22,0x00,0xE3,
  0xF8,0x04,0x00,0xFC,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0xFF,0xFF,0x00,0x00,0xFF,
  0x07,0x08,0x04,0x0B,0x04,0x0A,0x04,0x0A,0x04,0x0A,0x04,0x8A,0x04,0x8A,0x00,0x8E,
  0xF0,0x08,0x00,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x40,0xA0,0x40,0xA0,0x40,0xA0,0x40,0xA0,0x40,0xA0,0x40,0xA0,0x40,0xA0,0x00,0xE0,
  0x10,0x28,0x10,0x28,0x10,0x28,0x10,0x28,0x10,0x28,0x10,0x28,0x10,0x28,0x00,0x38,
  0x08,0x14,0x08,0x14,0x08,0x14,0x08,0x14,0x08,0x14,0x0C,0x13,0x07,0x08,0x00,0x07,
  0x08,0x14,0x08,0x14,0x08,0x14,0x08,0x14,0x08,0x14,0x18,0xE4,0xF0,0x08,0x00,0xF0,
  0x3F,0x40,0x20,0x5F,0x20,0x50,0x20,0x50,0x20,0x50,0x20,0x50,0x20,0x50,0x00,0x70,
  0x80,0x40,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x20,0x50,0x20,0x50,0x20,0x50,0x00,0x70,0x00,0x00,0x00,0x70,0x20,0x50,0x00,0x70,
  0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x07,0x1F,0x1F,0x3F,0x3F,0x7F,0x7F,0xFF,0xFF,
  0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xEF,0xFF,0xEE,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xE0,0xFC,0xFC,0xFF,0xFF,0xFF,0xFF,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0xF0,0xF0,
  0x03,0x03,0x0F,0x0F,0x1F,0x1F,0x3F,0x3F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xEF,0xFF,0xEF,0xFF,0xEF,0xFF,0xEF,0xFF,0xEF,
  0xF8,0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xDF,0xFF,0xBF,0xFF,0xBD,0xFF,0x7A,
  0x00,0x00,0x00,0x00,0xE0,0xE0,0xFC,0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xBF,0xBF,0xBF,0xBF,0x2F,0x2F,0x2B,0x2B,0x0A,0x0A,
  0xFF,0xDD,0xFF,0xDB,0xFF,0xD7,0xFF,0xCF,0xFF,0xFE,0xFF,0xFE,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xCF,0xFF,0xB7,0xFF,0xBF,0xFF,0x1F,0xFF,0xFE,0xFF,0xFD,0xFF,0x3D,0xFF,0xFB,
  0xFE,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0xFF,0xFF,0xFF,0xFC,0xFF,0xFB,0xFF,0xF7,
  0x00,0x00,0xC0,0xC0,0xF8,0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0xFF,0xF3,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xC0,0xF8,0xF8,0xFE,0xFE,0xFF,0xFF,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,
  0x7F,0x7F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x2F,0x2F,0x2F,0x2F,0x0B,0x0B,0x0B,0x0B,
  0xFF,0xEE,0xFF,0xED,0xFF,0xEB,0xFF,0xE7,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xF7,0xFF,0xF7,0xFF,0xE9,0xFF,0xDE,0xFF,0xBF,0xFF,0xBF,0xFF,0xCF,0xFF,0xF7,
  0xFF,0xBF,0xFF,0xFF,0xFF,0xFB,0xFF,0xF7,0xFF,0xEF,0xFF,0xDF,0xFF,0xDF,0xFF,0xBF,
  0x0A,0x0A,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xBF,0xBF,0xAF,0xAF,0xAB,0xAB,0x2A,0x2A,0x0A,0x0A,0x02,0x02,0x00,0x00,0x00,0x00,
  0xFF,0xF9,0xFF,0xFE,0xFF,0xFF,0xFF,0xFF,0xBF,0xBF,0x97,0x97,0x92,0x92,0x12,0x12,
  0xFF,0xEF,0xFF,0x6F,0xFF,0xEF,0xFF,0xF3,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x5F,0x5F,
  0xFF,0xED,0xFF,0xD9,0xFF,0xC7,0xFF,0xAF,0xFF,0x6E,0xFF,0xEE,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0x8F,0xFF,0x77,0xFF,0x7B,0xFF,0xFB,0xFF,0xFB,0xFF,0x77,0xFF,0x8F,
  0xE0,0xE0,0xF8,0xF8,0xFE,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x0A,0x0A,0x02,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xFF,0xFF,0xBF,0xBF,0xAF,0xAF,0xAB,0xAB,0x2A,0x2A,0x0A,0x0A,0x02,0x02,0x00,0x00,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xBF,0xBF,0xA7,0xA7,0xA5,0xA5,
  0xFF,0x7F,0xFF,0x9F,0xFF,0xE7,0xFF,0xFB,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x4B,0x4B,0x49,0x49,0x09,0x09,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xFF,0xFF,0x7F,0x7F,0x2F,0x2F,0x25,0x25,0x24,0x24,0x04,0x04,0x00,0x00,0x00,0x00,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x49,0x49,0x49,0x49,0x49,0x49,0x08,0x08,
  0xFE,0xFE,0xFC,0xFC,0xF4,0xF4,0xA4,0xA4,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0x00,
  0x81,0x81,0x80,0x80,0x00,0x00,0x00,0x00,0x01,0x01,0x02,0x02,0x0C,0x0C,0x70,0x70,
  0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x40,0x40,0x40,0x40,0x40,0x40,0x80,0x80,
  0x24,0x24,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xBF,0xBF,0x97,0x97,0x92,0x92,0x12,0x12,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x00,
  0x03,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x80,0x80,0x00,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x01,0x01,0x06,0x06,0x38,0x38,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x07,0x1F,0x18,0x7F,0x63,0xFF,0x87,
  0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0x3F,0xFF,0xC0,0xFF,0x00,0xFF,0x80,0x7F,0x40,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xC0,0xE0,0x20,0xF0,0x10,0xF0,0x10,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x03,0x03,0x07,0x07,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFC,0xFF,0xFF,0xFF,0xD7,
  0x01,0x01,0x03,0x02,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x03,0x02,
  0xFF,0x07,0xFE,0x1E,0xE4,0xE4,0x0F,0x0B,0x1F,0x10,0x7F,0x60,0xFF,0x80,0xFF,0x00,
  0x7F,0x4E,0x7D,0x5D,0xFD,0x9D,0xF9,0x19,0xF3,0x12,0xFF,0x0C,0xFF,0x00,0xFF,0x00,
  0xF8,0x08,0xF8,0x08,0xFC,0x04,0xFC,0x04,0xFE,0x42,0xFE,0x42,0xFF,0x21,0xFF,0x21,
  0x00,0x00,0x1F,0x1F,0x3F,0x3F,0x7F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x7F,
  0x00,0x00,0xE0,0xE0,0xFE,0xFE,0xFF,0x7F,0xFF,0x77,0xFF,0x6C,0xFF,0x5B,0xFF,0x31,
  0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xC0,0xF8,0xF8,0xFF,0xFF,0xFF,0x5F,0xFF,0xDF,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xE0,0xFC,0xFC,
  0x07,0x07,0x03,0x03,0x03,0x03,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xFF,0xCC,0xFF,0xD9,0xFF,0xFB,0xFF,0xFE,0xBF,0xBF,0xAF,0xAF,0x2B,0x2B,0x09,0x09,
  0xFE,0xFE,0xFF,0xBF,0xFF,0x77,0xFF,0x6E,0xFF,0xAD,0xFF,0xF4,0xFF,0xFD,0x7F,0x7F,
  0x00,0x00,0xC0,0xC0,0xF0,0xF0,0xFC,0xFC,0xFE,0x7E,0xFF,0xE7,0xFF,0x57,0xFF,0xCF,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,
  0x07,0x04,0x07,0x04,0x0F,0x09,0x0F,0x08,0x0F,0x08,0x0F,0x08,0x0F,0x08,0x07,0x04,
  0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x10,0xFF,0x00,0xFF,0x00,0xFF,0x00,
  0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x30,
  0xFF,0x10,0xFF,0x18,0xF7,0x14,0xF7,0x14,0xF3,0x12,0xF1,0x11,0xE0,0x20,0xC0,0x40,
  0xBF,0xBF,0x9F,0x9F,0x97,0x97,0x85,0x85,0x81,0x81,0x00,0x00,0x00,0x00,0x00,0x00,
  0xFF,0xF7,0xFF,0xF7,0xFF,0xF9,0xFF,0xFF,0x7F,0x7F,0x5F,0x5F,0x0B,0x0B,0x09,0x09,
  0xFF,0xBC,0xFF,0x7B,0xFF,0x77,0xFF,0x97,0xFF,0xF7,0xFF,0xF9,0xFF,0xFF,0x7F,0x7F,
  0xFF,0xFF,0xFF,0x7F,0xFF,0xC7,0xFF,0xB6,0xFF,0xAD,0xFF,0x5B,0xFF,0x6B,0xFF,0xEB,
  0x00,0x00,0xC0,0xC0,0xF0,0xF0,0xFC,0x7C,0xFF,0xBF,0xFF,0xBF,0xFF,0xBF,0xFF,0x7F,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,
  0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x2F,0x2F,0x25,0x25,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xFF,0xFF,0xFE,0xFE,0x92,0x92,0x92,0x92,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x80,0x80,0x84,0x84,0x04,0x04,0x08,0x08,0x70,0x70,0x00,0x00,0x03,0x03,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x20,0x20,0x40,0x40,0x80,0x80,0x00,0x00,
  0x03,0x02,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xFF,0x00,0xFF,0x83,0x7F,0x6C,0x1F,0x1F,0x01,0x01,0x01,0x01,0x01,0x01,0x07,0x07,
  0xFF,0xC1,0xFE,0x0E,0xF0,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xFF,0xFC,0xFF,0xFF,0xFF,0xFF,0xA4,0xA4,0x24,0x24,0x20,0x20,0x10,0x10,0x10,0x10,
  0xFF,0xFF,0xFE,0xFE,0xFA,0xFA,0x92,0x92,0x90,0x90,0x00,0x00,0x00,0x00,0x00,0x00,
  0x82,0x82,0x81,0x81,0x01,0x01,0x01,0x01,0x02,0x02,0x0C,0x0C,0x70,0x70,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x04,0x02,0x02,0x02,0x02,0x02,0x02,0x04,0x04,
  0x1F,0x19,0x3F,0x21,0x7F,0x41,0x7F,0x41,0x7F,0x43,0xFC,0x84,0xFC,0x84,0xF8,0x88,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x80,0xC0,0x80,0x60,0x40,
  0x10,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x04,0x04,0x44,0x44,0x44,0x44,0x44,0x44,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x08,0x08,
  0x18,0x18,0xE0,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x03,0x03,0x04,0x07,0x08,0x0F,0x08,0x0F,
  0xF8,0x08,0xF0,0x10,0xF0,0x10,0xF0,0x10,0xF0,0x10,0xF0,0xF0,0x10,0xF0,0x09,0xF9,
  0x70,0x40,0x7C,0x40,0x7F,0x40,0x7F,0x40,0xFF,0x83,0xFC,0x84,0xFC,0x84,0xF8,0x08,
  0x00,0x00,0x00,0x00,0xC0,0x00,0x80,0x80,0x00,0x00,0xC0,0xC0,0x30,0x30,0x0C,0x0C,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x02,0x03,0x02,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x00,0xFC,0x04,0xFB,0x0B,
  0x24,0x24,0x24,0x24,0x18,0x18,0x20,0x20,0x20,0x20,0x40,0x40,0x80,0x80,0x00,0x00,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x08,0x08,0x08,0x08,0x10,0x10,0x10,0x10,
  0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x04,0x04,0x04,0x02,0x02,0x02,0x02,0x02,0x02,
  0x00,0x00,0x01,0x01,0x02,0x02,0x04,0x04,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x80,0x80,0x00,0x00,0x18,0x18,0x20,0x20,0x40,0x40,0x41,0x41,0x03,0x03,
  0x04,0x07,0x03,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x09,0xF9,0x11,0xF1,0xE1,0xE1,0x01,0x01,0x01,0x01,0x03,0x03,0x04,0x07,0x04,0x07,
  0xF8,0x08,0xF8,0x08,0xF0,0x10,0xF0,0x10,0xF0,0x10,0xF0,0x10,0xE8,0xF8,0x04,0xFC,
  0x80,0x80,0x70,0x70,0x0F,0x0F,0x03,0x02,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,
  0x01,0x01,0x01,0x01,0xFF,0xFF,0xF1,0x11,0xF0,0x10,0xF0,0x10,0xF8,0x08,0xF8,0x88,
  0xFC,0x0C,0xF8,0x08,0xF8,0x08,0xF8,0x08,0xF8,0x88,0xFC,0x84,0x7C,0x44,0x7E,0x42,
  0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x03,0x0C,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,
  0x20,0x20,0x40,0x40,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x02,0x02,0x04,0x04,0x04,0x04,0x08,0x08,0x08,0x08,0x10,0x10,0x20,0x20,0x40,0x40,
  0x07,0x07,0x07,0x07,0x05,0x05,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xFF,0x2F,0xFF,0xAB,0xFF,0xFA,0x7F,0x7A,0x5F,0x5E,0x17,0x17,0x02,0x02,0x00,0x00,
  0x80,0x80,0xF0,0xF0,0xFC,0x7C,0xFE,0xDE,0xFF,0x93,0xFF,0xF7,0xFE,0xFE,0x54,0x54,
  0x04,0xFC,0x08,0xF8,0xF0,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xF8,0x88,0xFC,0x84,0x7C,0x44,0x7C,0x44,0x7E,0x4E,0x71,0x7F,0x81,0xFF,0x81,0xFF,
  0x3F,0x21,0x1F,0x11,0x1E,0x13,0x0C,0x0F,0x10,0x1F,0x10,0x1F,0x08,0x0F,0x07,0x07,
  0x00,0x00,0x80,0x80,0x40,0xC0,0x20,0xE0,0x20,0xE0,0x20,0xE0,0x40,0xC0,0x80,0x80,
  0x01,0x01,0x06,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x42,0x7E,0x3C,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x65,0x65,0x55,0x55,0x65,0x65,0x52,0x52,0x62,0x62,
  0x00,0x00,0x00,0x00,0x00,0x00,0x19,0x19,0x15,0x15,0x15,0x15,0x15,0x15,0x19,0x19,
  0x00,0x00,0x00,0x00,0x00,0x00,0x84,0x84,0x44,0x44,0x84,0x84,0x44,0x44,0x57,0x57,
  0x00,0x00,0x00,0x00,0x00,0x00,0x56,0x56,0x55,0x55,0x55,0x55,0x55,0x55,0x76,0x76,
  0x00,0x00,0x00,0x00,0x00,0x00,0x23,0x23,0x54,0x54,0x57,0x57,0x51,0x51,0x26,0x26
};


//======= MUSIC ==============

//Here is kind of "quick'n dirty" custom music player made using solely the Channel 2 of the GB
//The main parameters of the channel are set manually, then this table defines "notes", as in "frequencies" to play that will go to the NR23 & NR24 registers

//Here is the "note table". Each note is defined by 4 hexa numbers, directly setting the values for NR21, NR22, NR23 and NR24 registers, in that order
const UINT8 music_notes [] ={
	//NR21, NR22=Initial volume [0: silence / F: max] / Volume duration, NR23=Frequency 1/2, NR24=Note Durantion (C=short / 8=long) / Frequency 2/2 
	0x82, 0x47, 0x16, 0x84 //[0] C4 long
	,0x82, 0x47, 0x55, 0x83 //[1] A3 long
	,0x82, 0x47, 0xDA, 0x83 //[2] B3 long 
	,0x82, 0x47, 0xC5, 0x81 //[3] E3 long
	,0x82, 0x47, 0x16, 0xC4 //[4] C4 cut
	,0x82, 0x47, 0x55, 0xC3 //[5] A3 cut
	,0x82, 0x47, 0xDA, 0xC3 //[6] B3 cut
	,0x82, 0x47, 0xC5, 0xC1 //[7] E3 cut
	,0x82, 0xA5, 0x0A, 0x86 //[8] C5 long
	,0x82, 0xA5, 0xAC, 0x85 //[9] A4 long
	,0x82, 0xA5, 0xED, 0x85 //[10] B4 long 
	,0x82, 0xA5, 0xE5, 0x84 //[11] E4 long
	,0x82, 0xA2, 0x0A, 0x86 //[12] C5 short
	,0x82, 0xA2, 0xAC, 0x85 //[13] A4 short
	,0x82, 0xA2, 0xED, 0x85 //[14] B4 short 
	,0x82, 0xA2, 0xE5, 0x84 //[15] E4 short
};

//Here is the "partition" table. Each note is defined by two numbers in this array
//- The first number is the "note", an index to the "notes" tables array / 4 (as each note is defined by 4 entry in notes, we can use note 0,1,2,3... instead of note 0,4,8,12,16 - it's easier to read for us mere humans)
//- The second number is the "delay" after the next note : the player will wait XX cycles (max: 240 - 4 seconds (60 cycles per seconds) and play the next "note"
//Music Table Format: Note index in "music_notes" / 4, Delay before next note
const UINT8 music_intro [] ={
	4, 30 //C5
	,5, 30 //A4
	,7, 30 //E4
	,6, 30 //B4
	,4, 30 //C5
	,5, 30 //A4
	,7, 30 //E4
	,6, 30 //B4
	,0, 15 //C5
	,2, 15 //B4
	,1, 30 //A4
	,3, 30 //E4
	,2, 30 //B4
	,0, 30 //C5
	,1, 30 //A4
	,3, 30 //E4
	,2, 30 //B4
	,0, 30 //C5
	,1, 30 //A4
	,3, 30 //E4
	,2, 30 //B4
	,0, 15 //C5
	,2, 15 //B4
	,1, 15 //A4
	,1, 15 //A4
	,3, 15 //E4
	,3, 15 //E4
	,2, 15 //B4
	,2, 15 //B4
	,0, 15 //C5
	,0, 15 //C5
	,1, 15 //A4
	,1, 15 //A4
	,3, 15 //E4
	,3, 15 //E4
	,2, 15 //B4
	,2, 15 //B4
	,0, 15 //C5
	,2, 15 //B4
	,1, 15 //A4
	,1, 15 //A4
	,3, 15 //E4
	,3, 15 //E4
	,2, 15 //B4
	,2, 15 //B4
	,0, 15 //C5
	,0, 15 //C5
	,1, 15 //A4
	,1, 15 //A4
	,3, 15 //E4
	,3, 15 //E4
	,2, 15 //B4
	,2, 15 //B4
	,0, 15 //C5
	,0, 15 //C5
	,1, 15 //A4
	,1, 15 //A4
	,3, 15 //E4
	,3, 15 //E4
	,2, 15 //B4
	,2, 15 //B4
	,0, 15 //C5
	,2, 15 //B4
	,1, 15 //A4
	,1, 15 //A4
	,3, 15 //E4
	,3, 15 //E4
	,2, 15 //B4
	,2, 15 //B4
	//LOOP without "cut"
	,0, 30 //C5
	,1, 30 //A4
	,3, 30 //E4
	,2, 30 //B4
	,0, 30 //C5
	,1, 30 //A4
	,3, 30 //E4
	,2, 30 //B4
	,0, 15 //C5
	,2, 15 //B4
	,1, 30 //A4
	,3, 30 //E4
	,2, 30 //B4
	,0, 30 //C5
	,1, 30 //A4
	,3, 30 //E4
	,2, 30 //B4
	,0, 30 //C5
	,1, 30 //A4
	,3, 30 //E4
	,2, 30 //B4
	,0, 15 //C5
	,2, 15 //B4
	,1, 15 //A4
	,1, 15 //A4
	,3, 15 //E4
	,3, 15 //E4
	,2, 15 //B4
	,2, 15 //B4
	,0, 15 //C5
	,0, 15 //C5
	,1, 15 //A4
	,1, 15 //A4
	,3, 15 //E4
	,3, 15 //E4
	,2, 15 //B4
	,2, 15 //B4
	,0, 15 //C5
	,2, 15 //B4
	,1, 15 //A4
	,1, 15 //A4
	,3, 15 //E4
	,3, 15 //E4
	,2, 15 //B4
	,2, 15 //B4
	,0, 15 //C5
	,0, 15 //C5
	,1, 15 //A4
	,1, 15 //A4
	,3, 15 //E4
	,3, 15 //E4
	,2, 15 //B4
	,2, 15 //B4
	,0, 15 //C5
	,0, 15 //C5
	,1, 15 //A4
	,1, 15 //A4
	,3, 15 //E4
	,3, 15 //E4
	,2, 15 //B4
	,2, 15 //B4
	,0, 15 //C5
	,2, 15 //B4
	,1, 15 //A4
	,1, 15 //A4
	,3, 15 //E4
	,3, 15 //E4
	,2, 15 //B4
	,2, 15 //B4
};



//==========================================
//==========  VARIABLES & HEADERS ============
//==========================================


// FUNCTION DECLARATIONS
// INITIALISE OUR GAME
void initGame();		
// SIMPLE RECT TO RECT CHECK
UINT8 collisionCheck(UINT8, UINT8, UINT8, UINT8, UINT8, UINT8, UINT8, UINT8); 
//Display score using tilemap on the window
UINT8 displayScore(UINT8);


// VARIABLE DECLARATIONS - STORED IN RAM
//Looping variables
UINT8 i, j;

//Game State : ( 0 : Intro / 1 : game / 2 : game over / 3 : How to play)
UINT8 state;


//Player position
UINT8 playerX, playerY;
//Is player stickyed to a velcro platform? (255 : false / 0-254: current index of the platform we're stickyed to)
UINT8 sticky;
//Countdown : number of frame whenever you can be sticky (right after a jump, to avoid restikying the same platform)
UINT8 stickyNOT;
// HOLDS KEYS FOR THE PREVIOUS FRAME (so we can bitmask the new keys easily)
UINT8 lastKeys;

//Player velocity
INT8 speedX, speedY;

//Player Score (CAREFUL, can go only up to 255)
UINT8 score;
//ID of the previous velcro platform used : used to track whether the player goes up or not before adding points (or not !)
//Also used to check whether it's a simple jump (+1 pt) or a double jump (+3 pts)
UINT8 lastVelcro;


//Variable to check whether we already pressed key or not (to force player to release button before pressing it again)
UINT8 keyPressed; 

//Variable to record the amount of pixel to scroll
UINT8 scroller; 

//Ticks counter (frame counter + modulo computed each frame to trigger 3 "every X frame" counter, so we can move at speed slower than 60 pixel / seconds - 60fps game baby !)
//Frame counter (resetted every 240 frames (4 seconds), so it can be used for countdown too)
UINT8 ticks;
//Fast speed : triggered every 2 frames
UINT8 ticks_fast;
//Mid speed : triggered every 4 frames
UINT8 ticks_mid;
//Slow speed : triggered every 8 frames
UINT8 ticks_slow;




//Table for holding the data for the Velcro platfrom management (3 data * 6 obj = 18 entries)
//Data order : posX, posY, speedX
UINT8 velcro[18];

//Table for holding the data for the foe management (3 data * 6 obj = 18 entries)
UINT8 foe[10];	


//Background tiles (const => stored in rom)
const UINT8 bg_blank[1]={0x00};
const UINT8 bg_fill[1]={0x01};
const UINT8 bg_title[1]={0x09};

//Title banner at the bottom of the screen (const => stored in rom)
const UINT8 font_title[16]={0x34, 0x29, 0x26, 0x26, 0x31, 0x01, 0x2A, 0x35, 0x01, 0x36, 0x31, 0x02, 0x01, 0x01, 0x01};

//Counter used to display the score (5 slots, so maximum score is 99999 (more than a UINT16, thanks hand-made counter!)
UINT8 font_score[5];

//Counter used to keep track of the current "note" index in the music table sheet (it's an IUT16, because we want to play more than 256/2 notes in each song :))
UINT16 music_note;
//Counter used to track the delay between each "note" of the song
UINT8 music_tempo;


////////////////////////////////////////////////////////////////////////////////
// INIT GAME

void initGame(){
	
	// SEED OUR RANDOMIZER
	initrand(DIV_REG);															

	//Reset vars
	state=1;
	score=0;
	lastVelcro=3; //set to 3 because the first velcro the player can catch is actually 6 (2nd velco * 3)
	scroller=0;
	keyPressed=1; //Set to 1 in case the player didn't release the button after title screen
	
	//Reset music at the beginning
	music_note = 0;
	music_tempo = 0;
	
	//The player is not stickyed by default (but lies on the ground)
	sticky = 20;
	stickyNOT = 0;

	//Set the player initial position
	playerX = 80;
	playerY = 136;
	
	//Player Sprites
	set_sprite_tile(0,0);
	set_sprite_tile(1,2);
	
	//Reverse the sheep palette so it can appears white!
	set_sprite_prop(0, S_PALETTE | S_PRIORITY);
	set_sprite_prop(1, S_PALETTE | S_PRIORITY);
	
	
	//Velcro sprites
	for (i=0 ; i != 15 ; i+=3){
		
		//Set the sprite vars (offscreen by default - in the top border of 0-8 pixels)
		velcro[i]=8+(rand() % 152);
		velcro[i+1]=156-(i*10);
		velcro[i+2]=1;
	
		//Activate the sprites
		set_sprite_tile(2+i, 20);
		set_sprite_tile(3+i, 22);
		set_sprite_prop(2+i, S_PRIORITY);
		set_sprite_prop(3+i, S_PRIORITY);
	}
	
	//Hide the first two velco for beginning
	velcro[0+2]=10;
	velcro[3]=0;
	velcro[3+2]=10;
	
	//Background sprites : fill the screen white for starter
	for (j=0 ; j != 18 ; j++){
		for (i=0 ; i != 20 ; i++){		
			set_bkg_tiles(i,j,1,1,bg_blank);
		}
	}	
	
	//Load the GBDK default font (the tiles will be located on the BG VRAM between index 1-96 (0x01-0x60)
	font_init();
	color(BLACK, LTGREY, SOLID);
	font_load(font_ibm);
	
	//GUI : Use the window functionnality
	//Number tiles (0-9)are located between 0x11 and 0x1A in the default font
	//Set the window at the bottom of the screen
	move_win(0, 136);
	
	//First, write down the game title at the bottom, using the "map" (capital letters are located from 0x22 (=>A) )
	set_win_tiles(1,0,16,1,font_title);
	
	//Set the score displayer to the "0" tiles for starter
	font_score[0]=0x11;
	font_score[1]=0x11;
	font_score[2]=0x11;
	font_score[3]=0x11;
	font_score[4]=0x11;
	//Display the score for init
	set_win_tiles(16,0,5,1,font_score);
	
	// TURNS ON THE GAMEBOY LCD => Let's start!
	DISPLAY_ON;
}




////////////////////////////////////////////////////////////////////////////////
// MAIN FUNCTION

void main(){
	
	//Define the Intro Screen to start
	state = 0;
	
	// GAME LOOP START
	while(1){
		
		//GAMEPLAY STATE
		if( state == 1 ){
			
			//-= Frame & ticks counter =-
				
			//Increase the frame counter
			++ticks;
			
			//Reset it to zero every 4 seconds (UINT8 > 255 max, so 240 ticks => 4 seconds is ok)
			if (ticks == 241){
				ticks= 1;
			}
			
			//Update the "animation trigger" for everyone
			ticks_fast=!(ticks & 0x1);
			ticks_mid=!(ticks & 0x3);
			//ticks_slow=!(ticks & 0x7);
			ticks_slow=!(ticks % 10);

			
			
			//======= VELCRO =========
			
			//Update velcro sprites
			for (i=0 ; i != 15 ; i+=3){
				
				//Move Velcro in X (unless it's hidden)
				if( velcro[i+2] != 10 ){
					velcro[i] += velcro[i+2];
					//velcro[i]=80;
				}
				
				//If it hit the side border, it bounces back, unless it's hidden (speed = 10)
				if( velcro[i+2] != 10 && velcro[i] < 8 ){
					velcro[i]=8;
					velcro[i+2] = -velcro[i+2];
				}
				else if( velcro[i] > 153 ){
					velcro[i]=153;
					velcro[i+2] = -velcro[i+2];
				}
				
				//If the sheep isn't stickied yet
				if( sticky == 255 ){
					
					//Is this velcro collided with the sheep ? (excluding a "no-sticky" timeframe, and if the velcro isn't hidden)
					if( stickyNOT == 0 && velcro[i+2] != 10 && collisionCheck( playerX, playerY, 16, 8, velcro[i], velcro[i+1], 16, 8) ){
						
						//Play a scratching sound
						NR41_REG = 0x0A;
						NR42_REG = 0x0B;
						NR43_REG = 0x00;
						NR44_REG = 0xC0;
						/*
						//Play a scratching sound ORIG
						NR41_REG = 0x0A;
						NR42_REG = 0x0B;
						NR43_REG = 0x00;
						NR44_REG = 0xC0;
						
						//Play a scratching sound BIS
						NR41_REG = 0x00;
						NR42_REG = 0x2F;
						NR43_REG = 0x30;
						NR44_REG = 0xC0;
						*/
						//Set the sticky var to the current platform (id will be 0, 3, 6...18 and 20 is the ground) 
						sticky = i;
						
						//Use the ID of the last platfrom (3-based!) to see whether we went up or down or stayed the same
						//Gain a triple point for double jump
						if( 
							( i == lastVelcro+6 )
							|| ( i == 0 && lastVelcro == 9)
							|| ( i == 3 && lastVelcro == 12)
						){
							//Earn score points (only during the "peak" of the jump (speedY=0) => maximum height reached)
							score += 3;
							//Update also the score displayer
							displayScore(3);
							//Save the current velcro as last reached
							lastVelcro = i;
							//TODO : Bip sound
						}
						//Gain a single points
						else if(
							( i == lastVelcro+3 )
							|| ( i == 0 && lastVelcro == 12)
						){
							
							//Earn score points (only during the "peak" of the jump (speedY=0) => maximum height reached)
							score += 1;
							//Update also the score displayer
							displayScore(1);
							//Save the current velcro as last reached
							lastVelcro = i;
							//TODO : Bip sound
						}
						//else no points for you!
						

						//Move the sheep below the platform, because velcro is sticky
						playerX=velcro[i];
						playerY=velcro[i+1]+4;
						speedX=0;
						speedY=0;
					}
				}
				//If it's stickyed, is it with us?
				else if( sticky == i ){
					
					//Move the sheep according to the platform, because velcro is sticky
					playerX=velcro[i];
					playerY=velcro[i+1]+4;
				}
				
				//If we need to scroll, we do it!
				if( scroller != 0 ){
					
					velcro[i+1]+=1;
					
					//If it's to low, go on top (infinite scrolling effect!)
					if( velcro[i+1] > 160 ){
						
						//Moves back the velcro 150 pixels (5*30 pixels space between velcros = 150 pixels total height of the "velcro sheet", dispalyed on a 144 pixels tall screen
						velcro[i+1] -= 150;
						
						//Randomisator : set new X position and speed
						velcro[i]=8+(rand() % 152);
						velcro[i+2]=rand() % 4;
						
						//If the velcro is due to be stopped, we'll verify that it won't create an impossible jump
						if( velcro[i+2] == 0 ){ 
							
							//Debug
							//printf("STOP %u\n", (UINT16)i );
							
							//Prevent 2 following velcros to be stopped or hidden (else you cannot make such a big jump!)
							if( i != 0 && (velcro[i-1] == 0 || velcro[i-1] == 10) ){
								
								//Randomize the value again
								velcro[i+2]=(rand() % 4);
								
								//If the new value is below 1, we force it 1
								if( velcro[i+2] < 1 ){ velcro[i+2] = 1; }
								
								//Debug
								//printf("FIX %u=%u\n", (UINT16)i, (UINT16)velcro[i+2] );
								//printf("FIX %u=%d\n", (UINT16)i, (INT16)velcro[i+2] );
							}
							else if( i == 0 && (velcro[14] == 0 || velcro[14] == 10) ){
								
								//Randomize the value again
								velcro[i+2]=(rand() % 4);
								
								//If the new value is below 1, we force it 1
								if( velcro[i+2] < 1 ){ velcro[i+2] = 1; }
								
								//Debug
								//printf("FIX %u=%u\n", (UINT16)i, (UINT16)velcro[i+2] );
								//printf("FIX %u=%d\n", (UINT16)i, (INT16)velcro[i+2] );
							}
							
						}
						
						//If the velcro is STILL due to be stopped (but is not hidden yet)
						if( velcro[i+2] == 0 ){ 
							
							//Starting a certain thresold, hide the velcro instead of stopping it (double jump required!)
							//Over 100, it will  be always a hidden for increased difficulty
							if( score > 100 ){
								//Instead of stopped, force a double jump
								velcro[i+2] = 10;
								velcro[i] = 0;
							}
							//After 30, 50% chance of getting a hidden velcro instead of a stopped one
							else if ( score > 30 && rand() % 2 == 0 ){
								velcro[i+2] = 10;
								velcro[i] = 0;
							}
						}
						
					}
				}
				
				//Update Velcro Sprite Pos
				move_sprite(2+i, velcro[i], velcro[i+1]);
				move_sprite(3+i, velcro[i]+8, velcro[i+1]);
				
				//If the velcro is hidden, move the second sprite inside the left border instead of next to the other part
				if(  velcro[i+2] == 10 ){ 
					move_sprite(3+i, velcro[i], velcro[i+1] ); 
				}
			}
	
			
			//======= PLAYER =========
			
			//BUTTON PRESSED
			if ( joypad() & J_B ){
				
				//Only if stickyed (ground is sticky == 20) & do it only once per keypressed
				if( sticky != 255 && !keyPressed ){
					
					//Jump power!
					speedY = -3;
					
					//Reset frame counter for accurate jump length
					ticks=0;
					ticks_fast=0;
					ticks_mid=0;
					ticks_slow=0;
					
					//Play a scratching sound, if we're not on the ground
					if( sticky != 20 ){
				
						//Better jump sound
						NR10_REG = 0x15;
						NR11_REG = 0x96;
						NR12_REG = 0x73;
						NR13_REG = 0xBB;
						NR14_REG = 0x85;
					}
					//Else play a normal "jumping" sound
					else {
						/*
						//Quick jump sound
						NR10_REG = 0x13;
						NR11_REG = 0x09;
						NR12_REG = 0x43;
						NR13_REG = 0xF6;
						NR14_REG = 0x81;
						
						//Louder jump sound
						NR10_REG = 0x15;
						NR11_REG = 0x09;
						NR12_REG = 0x43;
						NR13_REG = 0xF6;
						NR14_REG = 0x81;
						*/
						//Better jump sound
						NR10_REG = 0x15;
						NR11_REG = 0x96;
						NR12_REG = 0x73;
						NR13_REG = 0xBB;
						NR14_REG = 0x85;
						
						/*
						
						//Better jump sound ORIG
						NR10_REG = 0x15;
						NR11_REG = 0x96;
						NR12_REG = 0x73;
						NR13_REG = 0xBB;
						NR14_REG = 0x85;
						
						
						//Game Over sound
						NR10_REG = 0x1D;
						NR11_REG = 0x96;
						NR12_REG = 0x73;
						NR13_REG = 0xBB;
						NR14_REG = 0x85;
						*/
					}
					
					//Unstick the sheep
					sticky=255;
					
					//Set the no stick counter
					stickyNOT=10;
					
					//Record that the key was pressed
					keyPressed = 1;
				}
			}	
			//If key isn't pressed, record that player released the key
			else if( keyPressed ){
				keyPressed = 0;
			}
			
			//PLAYER : Y Movement
	
			//If not stickyied
			if( sticky == 255 ){
				
				//Ohh, gravity !
				if( ticks_slow ){
					speedY++;
				}
				
				//Udpate position
				playerY += speedY;
				
				//Don't go out of the screen on top (prevent "wrapping sprite" effect)
				if( playerY < 16 ){
					playerY=16;
				}
				
				//Game beginning : are you hitting the ground ?
				if( score < 3 && playerY > 136 ){
					//Game beginning : stay safe on the ground
					playerY=136;
					speedY = 0;
					//Set "sticky" to the ground (id=>20)
					sticky=20;
				}

			}
			
			
			//Or if game started, are you falling out of screen bottom?
			if( score > 2 && playerY > 160 ){
				//Define the game over state
				state=2;
				
				//Sound : Game Over sound
				NR10_REG = 0x4F; //or 1E or 1D for louder sound / 2E / 3E / 4E... for more "vibe"
				NR11_REG = 0x96;
				NR12_REG = 0xB7; //B7, C7, D7...F7 for longer sound
				NR13_REG = 0xBB;
				NR14_REG = 0x85;
				
				//Display a Game Over screen using the handy (but buggy) printf function from GBDK
				printf("\n\n\n\n\n\n     GAME OVER      \n");
				printf("\n press B to restart ");
				
				//Set a countdown before we can a press a key again to continue
				stickyNOT = 40;
			}
			
			//Player : update sprite animation
			//If the sprite is stickied
			if( sticky != 255 ){
				set_sprite_tile(0,0);
				set_sprite_tile(1,2);
			} else {
				//Set the jumping frame according to speed
				if( speedY < 0 ){
					set_sprite_tile(0,4);
					set_sprite_tile(1,6);
				} else {
					set_sprite_tile(0,8);
					set_sprite_tile(1,10);
				}
			}
			
			
			//Decrease the stickyNOT counter (used to prevent being "restickyed" to the start velcro when jumping)
			if( stickyNOT != 0 ){
				stickyNOT--;
			}
			
			//Do we need to scroll the screen? (applied only when sticky => more fair in case we misses a jump :))
			if( playerY < 56 && sticky != 255 ){
				//Scroll down 2 velcros : 2*30 pixel between each velcro = 60 pixels
				scroller=60; 
			}
			
		
			
			//If we need to scroll, we do it!
			if( scroller != 0 ){
				//Decrease remaining scrolling
				scroller--;
				
				//Move Player Y down (because Velcro only scroll themselves, not the sheep)
				playerY++;
				
				//TODO; move the tile background too
			}
			
			//PLAYER : Update sprite positions on screen
			move_sprite(0, playerX, playerY);
			move_sprite(1, playerX+8, playerY);
			/*
			if( sticky != 255 ){
				if ( sticky == 0 ){ printf("0\n"); }
				if ( sticky == 20 ){ printf("20\n"); }		
			} else {
				printf("!NO!\n");
			}
			*/
			
			//printf("%s \n",score);
			
		
			//======= MISC =========
			/*
			//CHEAT MODE
			if ( joypad() & J_A ){
				score++;
				displayScore(1);
			}
			if ( joypad() & J_START ){
				scroller += 30;
			}
			*/
			
			//Play some music
			if( music_tempo == 0 ){
				//Play current note ( << 2 is like a *4 (bitshift is faster than * for the GB), because music note is 0,1,2,3,4... while our actual note array uses 4 entry per note, 
				//so we have to multiply note by 4 to get the actual registers index for each note)
				NR21_REG = music_notes[ music_intro[music_note]<<2 ];
				NR22_REG = music_notes[ (music_intro[music_note]<<2)+1 ];
				NR23_REG = music_notes[ (music_intro[music_note]<<2)+2 ];
				NR24_REG = music_notes[ (music_intro[music_note]<<2)+3 ];
				
				//Set the new delay to wait
				music_tempo = music_intro[ music_note+1 ];
				
				//Skip to the next note
				music_note += 2;
				//Loop if needed //OLD : if( music_note > ( sizeof( music_intro) / sizeof (music_intro[0]) )-1 ){ //= sizeof( UINT8) is 1 with gbdk, so we don't need this useless division => save some CPU)
				if( music_note > sizeof(music_intro)-1 ){
					music_note = 0;
				}
			}
			//Else wait for the next note to play
			else {
				music_tempo--;
			}
			
		}
		
		//GAME OVER SCREEN
		else if ( state == 2 ){
			
			//BUTTON PRESSED
			if ( joypad() & J_B ){
				
				//Only once per keyPress (including from previous screen), and after a tiny countdown to avoid non-desired restart because we were "hitting keys like crazy" inside the game
				if( !keyPressed && stickyNOT == 0 ){
				
					//Shutdown the display during restart (avoid glitches and save cpu power)
					DISPLAY_OFF;
					HIDE_WIN;
					HIDE_SPRITES;
					HIDE_BKG;	

					//Restart Game
					initGame();
				}
				
				//Record the keypress
				keyPressed = 1;
			}
			//If key isn't pressed, record that player released the key
			else if( keyPressed ){
				keyPressed = 0;
			}
			
			//Decrease the stickyNOT counter (used to prevent being "restickyed" to the start velcro when jumping)
			if( stickyNOT != 0 ){
				stickyNOT--;
			}
		}
		
		//INTRO SCREEN
		else if ( state == 0 ){
			
			//Init the game once, and drawn the title screen 
			//(use the score var to track that we'll do this only once, as the var will be be reseted at game startup)
			if( score != 1 ){
				
				// TURNS ON THE GAMEBOY LCD => Let's start!
				DISPLAY_ON;
				
				// TURN SOUND ON
				//NR52_REG = 0x8F;
				NR52_REG = 0x80;
				// ENABLE SOUND CHANNELS (1: 0x11 / 2: 0x22 / 3: 0x44 / 4: 0x88 / All : 0xFF)
				NR51_REG = 0xFF;
				// VOLUME MAX = 0x77, MIN = 0x00	
				NR50_REG = 0x77;

				//Set sprites to 8x16
				SPRITES_8x16;
				
				//Load the player sprites into Sprite VRAM (start: 0)
				set_sprite_data(0, 12, gfx_sheep);
					
				//Load the velcro sprites into Sprite VRAM (start: 20)
				set_sprite_data(20, 4, gfx_velcro);	

				//Moves the window offscreen to be able to see the title display on BKG
				move_win(0, 144);
				
				// INTRO SCREEN
				
				//Load the title screen tiles in the Background VRAM
				//These tiles are used in separate maps below (because GBDK can't load a map with more than 256 tiles at once, as it uses UINT8 params)
				set_bkg_data(0, 255, title_tile_data);
				
				//Background sprites : fill the screen white for starter (tile 0x09 in the title screen image)
				for (j=0 ; j != 18 ; j++){
					for (i=0 ; i != 20 ; i++){		
						set_bkg_tiles(i,j,1,1,bg_title);
					}
				}	
				
				//Use Map Data to display the Title Screen
				
				//First the game name
				set_bkg_tiles(1,1,18,2, title_name_map_data);
				
				//Then the game intro picture
				set_bkg_tiles(2,4,18,16, title_picture_map_data);
				
				
				// MUSIC
				
				//Play Some Music
				music_note = 0;
				music_tempo = 0;
				
				//Init the Channel 2 Registers to play Music
				NR21_REG = 0x82;
				NR22_REG = 0xA5; //A2, A3, A4, A5... the larger the second digit, the longer the note is
				NR23_REG = 0xFC;
				NR24_REG = 0x84;

				//Do only once!
				score = 1;
			}

			//Play some music
			if( music_tempo == 0 ){
				//Play current note ( << 2 is like a *4 (bitshift is faster than * for the GB), because music note is 0,1,2,3,4... while our actual note array uses 4 entry per note, 
				//so we have to multiply note by 4 to get the actual registers index for each note)
				NR21_REG = music_notes[ music_intro[music_note]<<2 ];
				NR22_REG = music_notes[ (music_intro[music_note]<<2)+1 ];
				NR23_REG = music_notes[ (music_intro[music_note]<<2)+2 ];
				NR24_REG = music_notes[ (music_intro[music_note]<<2)+3 ];
				
				//Set the new delay to wait
				music_tempo = music_intro[ music_note+1 ];
				
				//Skip to the next note
				music_note += 2;
				//Loop if needed //OLD : if( music_note > ( sizeof( music_intro) / sizeof (music_intro[0]) )-1 ){ //= sizeof( UINT8) is 1 with gbdk, so we don't need this useless division => save some CPU)
				if( music_note > sizeof(music_intro)-1 ){
					music_note = 0;
				}
			}
			//Else wait for the next note to play
			else {
				music_tempo--;
			}
			
			
			//BUTTON PRESSED
			if ( joypad() & J_B ){
				
				//Only once per keyPress (including from previous screen
				if( !keyPressed ){
				
					//Reset the screen init variable
					score = 0;
					
					//Define the state as instruction screen
					state = 3;
				}
			}
			//If key isn't pressed, record that player released the key
			else if( keyPressed ){
				keyPressed = 0;
			}
		}
	
		//INSTRUCTION SCREEN
		else if ( state == 3 ){
			
			//Init the game once, and drawn the title screen 
			//(use the score var to track that we'll do this only once, as the var will be be reseted at game startup)
			if( score != 1 ){
				
				//Load the GBDK default font (the tiles will be located on the BG VRAM between index 1-96 (0x01-0x60)
				font_init();
				//color(BLACK, LTGREY, SOLID);
				color(BLACK, WHITE, SOLID);
				font_load(font_ibm);
				
				//Load the background sprites into Background VRAM
				//Note : THE WINDOW LAYER SHARED THE BKG VRAM BY DEFAULT
				set_bkg_data(0, 1, gfx_bg);
				
				//Moves the window offscreen to be able to see the title display on BKG
				move_win(0, 144);
				
				//Background sprites : fill the screen white for starter
				for (j=0 ; j != 18 ; j++){
					for (i=0 ; i != 20 ; i++){		
						set_bkg_tiles(i,j,1,1,bg_fill);
					}
				}	
				
				//Display the title (quick'n dirty using printf)
				printf("\n -= HOW TO PLAY =-\n");
				//printf("\n\n\n\n\n\n\n\n\n\n\n");
				//printf("\n\n Press B to jump.\n\n Climb up to the top using the floating  velcro bands.\n\n Don't fall down!\n\n");
				printf("\n\n Press B to jump.\n\n Hang on the flying\n velcro straps to\n climb up.\n");
				printf("\n Short jump= +1 pt\n  Long jump= +3 pts\n\n");
				printf("\n Don't fall down!\n\n");
				printf("                    ");
				//Use a different colored font for the last line
				color(BLACK, LTGREY, SOLID);
				font_load(font_ibm);
				printf("  Press B to start ");
				//Do only once!
				score = 1;
			}

			//BUTTON PRESSED
			if ( joypad() & J_B ){
				
				//Only once per keyPress (including from previous screen
				if( !keyPressed ){
				
					//Let's start the game !
					initGame();
					
					//Define the state as game
					state = 1;
				}
			}
			//If key isn't pressed, record that player released the key
			else if( keyPressed ){
				keyPressed = 0;
			}
		}


		//Update Display
		//HIDE_WIN;																// SHOW WINDOW LAYER
		SHOW_WIN;
		SHOW_SPRITES;															// HIDE SPRITES LAYER
		SHOW_BKG;																// SHOW BACKGROUND LAYER
		
		//Update keypresses
		lastKeys = joypad();
		// WAIT FOR VBLANK TO FINISH - ENSURES 60 FRAMES PER SECOND MAXIMUM
		wait_vbl_done();														
	}
	// GAME LOOP END

}

//This function display the score onscreen - each time it's called it'll add the value passed as parameters
//As I couldn't figure out to make a UINT16 => Tilemap converter in a quick and efficient way, I choose to handle score differently
//The "score" variable, a UINT16, will track the score for internal purpose (adjust difficulty as score increases)
//However, as this value won't be displayed directly, I'll also separatedly update "tilemap" to display the current score with font tilemap on the window
UINT8 void displayScore ( UINT8 value ){
	
	//Add the value to the digit counter
	font_score[4] += value;
	//Check whether we have to increase other counters (10's, 100's, etc.)
	//10's
	if( font_score[4] > 0x1A ){ 
		font_score[3]++;
		font_score[4]-=10;
	}
	//100's
	if( font_score[3] > 0x1A ){ 
		font_score[2]++;
		font_score[3]-=10;
	}
	//1000's
	if( font_score[2] > 0x1A ){ 
		font_score[1]++;
		font_score[2]-=10;
	}
	//10000's
	if( font_score[1] > 0x1A ){ 
		font_score[0]++;
		font_score[1]-=10;
	}
	
	//Draw the current score to the window
	set_win_tiles(16,0,5,1,font_score);
}


////////////////////////////////////////////////////////////////////////////////
// COLLISION CHECKER - SIMPLE RECTANGLE COLLISION CHECKING (coming straight from Refresh Game GBDK Template : refreshgames.co.uk)
// RETURNS 1 IF OVERLAPPING
UINT8 collisionCheck(UINT8 x1, UINT8 y1, UINT8 w1, UINT8 h1, UINT8 x2, UINT8 y2, UINT8 w2, UINT8 h2){

	if ((x1 < (x2+w2)) && ((x1+w1) > x2) && (y1 < (h2+y2)) && ((y1+h1) > y2)){
		return 1;
	} else {
		return 0;
	}

}